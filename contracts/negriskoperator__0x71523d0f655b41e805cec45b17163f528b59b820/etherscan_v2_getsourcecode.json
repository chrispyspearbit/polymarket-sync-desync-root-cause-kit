{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/NegRiskOperator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {NegRiskAdapter} from \\\"src/NegRiskAdapter.sol\\\";\\nimport {Auth} from \\\"src/modules/Auth.sol\\\";\\nimport {IAuthEE} from \\\"src/modules/interfaces/IAuth.sol\\\";\\nimport {NegRiskIdLib} from \\\"src/libraries/NegRiskIdLib.sol\\\";\\n\\n/// @title INegRiskOperatorEE\\n/// @notice NegRiskOperator Errors and Events\\ninterface INegRiskOperatorEE is IAuthEE {\\n    error OnlyOracle();\\n    error OracleAlreadyInitialized();\\n    error OnlyNegRiskAdapter();\\n    error InvalidPayouts();\\n    error OnlyFlagged();\\n    error OnlyNotFlagged();\\n    error NotEligibleForEmergencyResolution();\\n    error DelayPeriodNotOver();\\n    error ResultNotAvailable();\\n    error QuestionWithRequestIdAlreadyPrepared();\\n    error InvalidRequestId();\\n    error QuestionAlreadyReported();\\n\\n    event MarketPrepared(bytes32 indexed marketId, uint256 feeBips, bytes data);\\n    event QuestionPrepared(\\n        bytes32 indexed marketId,\\n        bytes32 indexed questionId,\\n        bytes32 indexed requestId,\\n        uint256 questionIndex,\\n        bytes data\\n    );\\n    event QuestionFlagged(bytes32 indexed questionId);\\n    event QuestionUnflagged(bytes32 indexed questionId);\\n    event QuestionReported(bytes32 indexed questionId, bytes32 requestId, bool result);\\n    event QuestionResolved(bytes32 indexed questionId, bool result);\\n    event QuestionEmergencyResolved(bytes32 indexed questionId, bool result);\\n}\\n\\n/// @title NegRiskOperator\\n/// @notice Permissioned Operator for interacting with the NegRiskAdapter\\n/// @author Mike Shrieve (mike@polymarket.com)\\ncontract NegRiskOperator is INegRiskOperatorEE, Auth {\\n    /*//////////////////////////////////////////////////////////////\\n                                 STATE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    NegRiskAdapter public immutable nrAdapter;\\n    address public oracle;\\n    uint256 public constant DELAY_PERIOD = 1 hours;\\n\\n    mapping(bytes32 _requestId => bytes32) public questionIds;\\n    mapping(bytes32 _questionId => bool) public results;\\n    mapping(bytes32 _questionId => uint256) public flaggedAt;\\n    mapping(bytes32 _questionId => uint256) public reportedAt;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               MODIFIERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    modifier onlyOracle() {\\n        if (msg.sender != oracle) revert OnlyOracle();\\n        _;\\n    }\\n\\n    modifier onlyNotFlagged(bytes32 _questionId) {\\n        if (flaggedAt[_questionId] > 0) revert OnlyNotFlagged();\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @param _nrAdapter - the address of the NegRiskAdapter\\n    constructor(address _nrAdapter) {\\n        nrAdapter = NegRiskAdapter(_nrAdapter);\\n    }\\n\\n    /// @notice Sets the oracle address\\n    /// @notice OnlyAdmin\\n    /// @notice Can only be called once\\n    /// @param _oracle - the address of the oracle\\n    function setOracle(address _oracle) external onlyAdmin {\\n        if (oracle != address(0)) revert OracleAlreadyInitialized();\\n        oracle = _oracle;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             PREPARE MARKET\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Prepares a market on the NegRiskAdapter\\n    /// @param _feeBips  - the market's fee rate out of 10_000\\n    /// @param _data     - the market metadata to be passed to the NegRiskAdapter\\n    /// @return marketId - the market id\\n    function prepareMarket(uint256 _feeBips, bytes calldata _data) external onlyAdmin returns (bytes32) {\\n        bytes32 marketId = nrAdapter.prepareMarket(_feeBips, _data);\\n        emit MarketPrepared(marketId, _feeBips, _data);\\n        return marketId;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            PREPARE QUESTION\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Prepares a question on the NegRiskAdapter\\n    /// @notice OnlyAdmin\\n    /// @notice Only one question can be prepared per requestId\\n    /// @param _marketId   - the id of the market in which to prepare the question\\n    /// @param _data       - the question metadata to be passed to the NegRiskAdapter\\n    /// @param _requestId  - the question's oracle request id\\n    /// @return questionId - the resulting question id\\n    function prepareQuestion(bytes32 _marketId, bytes calldata _data, bytes32 _requestId)\\n        external\\n        onlyAdmin\\n        returns (bytes32)\\n    {\\n        if (questionIds[_requestId] != bytes32(0)) {\\n            revert QuestionWithRequestIdAlreadyPrepared();\\n        }\\n\\n        bytes32 questionId = nrAdapter.prepareQuestion(_marketId, _data);\\n\\n        questionIds[_requestId] = questionId;\\n\\n        emit QuestionPrepared(_marketId, questionId, _requestId, NegRiskIdLib.getQuestionIndex(questionId), _data);\\n        return questionId;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             REPORT PAYOUTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Reports the outcome for a question\\n    /// @notice OnlyOracle\\n    /// @notice Only one report can be made per question\\n    /// @notice Sets the boolean result and reportedAt timestamp for the question\\n    /// @param _requestId - the question's oracle request id\\n    /// @param _payouts   - the payouts to be reported, [1,0] if true, [0,1] if false, any other payouts are invalid\\n    function reportPayouts(bytes32 _requestId, uint256[] calldata _payouts) external onlyOracle {\\n        if (_payouts.length != 2) {\\n            revert InvalidPayouts();\\n        }\\n\\n        uint256 payout0 = _payouts[0];\\n        uint256 payout1 = _payouts[1];\\n\\n        if (payout0 + payout1 != 1) {\\n            revert InvalidPayouts();\\n        }\\n\\n        bytes32 questionId = questionIds[_requestId];\\n\\n        if (questionId == bytes32(0)) {\\n            revert InvalidRequestId();\\n        }\\n\\n        if (reportedAt[questionId] > 0) {\\n            revert QuestionAlreadyReported();\\n        }\\n\\n        bool result = payout0 == 1 ? true : false;\\n\\n        results[questionId] = result;\\n        reportedAt[questionId] = block.timestamp;\\n\\n        emit QuestionReported(questionId, _requestId, result);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            RESOLVE QUESTION\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Resolves a question on the NegRiskAdapter\\n    /// @notice OnlyNotFlagged\\n    /// @notice A question can only be resolved if the delay period has passed since the question was reported\\n    /// @param _questionId - the id of the question to be resolved\\n    function resolveQuestion(bytes32 _questionId) external onlyNotFlagged(_questionId) {\\n        uint256 reportedAt_ = reportedAt[_questionId];\\n\\n        if (reportedAt_ == 0) revert ResultNotAvailable();\\n        if (block.timestamp < reportedAt_ + DELAY_PERIOD) {\\n            revert DelayPeriodNotOver();\\n        }\\n\\n        bool result = results[_questionId];\\n        nrAdapter.reportOutcome(_questionId, result);\\n\\n        emit QuestionResolved(_questionId, result);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 ADMIN\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Flags a question, preventing it from being resolved\\n    /// @param _questionId - the id of the question to be flagged\\n    function flagQuestion(bytes32 _questionId) external onlyAdmin onlyNotFlagged(_questionId) {\\n        flaggedAt[_questionId] = block.timestamp;\\n        emit QuestionFlagged(_questionId);\\n    }\\n\\n    /// @notice Unflags a question, allowing it to be resolved normally\\n    /// @param _questionId - the id of the question to be unflagged\\n    function unflagQuestion(bytes32 _questionId) external onlyAdmin {\\n        if (flaggedAt[_questionId] == 0) revert OnlyFlagged();\\n        flaggedAt[_questionId] = 0;\\n        emit QuestionUnflagged(_questionId);\\n    }\\n\\n    /// @notice Resolves a flagged question on the NegRiskAdapter\\n    /// @notice OnlyAdmin\\n    /// @notice A flagged question can only be resolved if the delay period has passed since the question was flagged\\n    /// @param _questionId - the id of the question to be resolved\\n    /// @param _result     - the boolean result of the question\\n    function emergencyResolveQuestion(bytes32 _questionId, bool _result) external onlyAdmin {\\n        uint256 flaggedAt_ = flaggedAt[_questionId];\\n\\n        if (flaggedAt_ == 0) revert OnlyFlagged();\\n        if (block.timestamp < flaggedAt_ + DELAY_PERIOD) {\\n            revert DelayPeriodNotOver();\\n        }\\n\\n        nrAdapter.reportOutcome(_questionId, _result);\\n        emit QuestionEmergencyResolved(_questionId, _result);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 NO-OP\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Allows the Oracle to treat the Operator like the CTF, i.e., to call prepareCondition\\n    function prepareCondition(address, bytes32, uint256) external {\\n        // no-op\\n    }\\n}\\n\"\r\n    },\r\n    \"src/NegRiskAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {ERC1155TokenReceiver} from \\\"lib/solmate/src/tokens/ERC1155.sol\\\";\\nimport {ERC20} from \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {WrappedCollateral} from \\\"src/WrappedCollateral.sol\\\";\\nimport {MarketData, MarketStateManager, IMarketStateManagerEE} from \\\"src/modules/MarketDataManager.sol\\\";\\nimport {CTHelpers} from \\\"src/libraries/CTHelpers.sol\\\";\\nimport {Helpers} from \\\"src/libraries/Helpers.sol\\\";\\nimport {NegRiskIdLib} from \\\"src/libraries/NegRiskIdLib.sol\\\";\\nimport {IConditionalTokens} from \\\"src/interfaces/IConditionalTokens.sol\\\";\\nimport {Auth} from \\\"src/modules/Auth.sol\\\";\\nimport {IAuthEE} from \\\"src/modules/interfaces/IAuth.sol\\\";\\n\\n/// @title INegRiskAdapterEE\\n/// @notice NegRiskAdapter Errors and Events\\ninterface INegRiskAdapterEE is IMarketStateManagerEE, IAuthEE {\\n    error InvalidIndexSet();\\n    error LengthMismatch();\\n    error UnexpectedCollateralToken();\\n    error NoConvertiblePositions();\\n    error NotApprovedForAll();\\n\\n    event MarketPrepared(bytes32 indexed marketId, address indexed oracle, uint256 feeBips, bytes data);\\n    event QuestionPrepared(bytes32 indexed marketId, bytes32 indexed questionId, uint256 index, bytes data);\\n    event OutcomeReported(bytes32 indexed marketId, bytes32 indexed questionId, bool outcome);\\n    event PositionSplit(address indexed stakeholder, bytes32 indexed conditionId, uint256 amount);\\n    event PositionsMerge(address indexed stakeholder, bytes32 indexed conditionId, uint256 amount);\\n    event PositionsConverted(\\n        address indexed stakeholder, bytes32 indexed marketId, uint256 indexed indexSet, uint256 amount\\n    );\\n    event PayoutRedemption(address indexed redeemer, bytes32 indexed conditionId, uint256[] amounts, uint256 payout);\\n}\\n\\n/// @title NegRiskAdapter\\n/// @notice Adapter for the CTF enabling the linking of a set binary markets where only one can resolve true\\n/// @notice The adapter prevents more than one question in the same multi-outcome market from resolving true\\n/// @notice And the adapter allows for the conversion of a set of no positions, to collateral plus the set of\\n/// complementary yes positions\\n/// @author Mike Shrieve (mike@polymarket.com)\\ncontract NegRiskAdapter is ERC1155TokenReceiver, MarketStateManager, INegRiskAdapterEE, Auth {\\n    using SafeTransferLib for ERC20;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 STATE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    IConditionalTokens public immutable ctf;\\n    ERC20 public immutable col;\\n    WrappedCollateral public immutable wcol;\\n    address public immutable vault;\\n\\n    address public constant NO_TOKEN_BURN_ADDRESS = address(bytes20(bytes32(keccak256(\\\"NO_TOKEN_BURN_ADDRESS\\\"))));\\n    uint256 public constant FEE_DENOMINATOR = 10_000;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @param _ctf        - ConditionalTokens address\\n    /// @param _collateral - collateral address\\n    constructor(address _ctf, address _collateral, address _vault) {\\n        ctf = IConditionalTokens(_ctf);\\n        col = ERC20(_collateral);\\n        vault = _vault;\\n\\n        wcol = new WrappedCollateral(_collateral, col.decimals());\\n        // approve the ctf to transfer wcol on our behalf\\n        wcol.approve(_ctf, type(uint256).max);\\n        // approve wcol to transfer collateral on our behalf\\n        col.approve(address(wcol), type(uint256).max);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                  IDS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Returns the conditionId for a given questionId\\n    /// @param _questionId  - the questionId\\n    /// @return conditionId - the corresponding conditionId\\n    function getConditionId(bytes32 _questionId) public view returns (bytes32) {\\n        return CTHelpers.getConditionId(\\n            address(this), // oracle\\n            _questionId,\\n            2 // outcomeCount\\n        );\\n    }\\n\\n    /// @notice Returns the positionId for a given questionId and outcome\\n    /// @param _questionId  - the questionId\\n    /// @param _outcome     - the boolean outcome\\n    /// @return positionId  - the corresponding positionId\\n    function getPositionId(bytes32 _questionId, bool _outcome) public view returns (uint256) {\\n        bytes32 collectionId = CTHelpers.getCollectionId(\\n            bytes32(0),\\n            getConditionId(_questionId),\\n            _outcome ? 1 : 2 // 1 (0b01) is yes, 2 (0b10) is no\\n        );\\n\\n        uint256 positionId = CTHelpers.getPositionId(address(wcol), collectionId);\\n        return positionId;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             SPLIT POSITION\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Splits collateral to a complete set of conditional tokens for a single question\\n    /// @notice This function signature is the same as the CTF's splitPosition\\n    /// @param _collateralToken - the collateral token, must be the same as the adapter's collateral token\\n    /// @param _conditionId - the conditionId for the question\\n    /// @param _amount - the amount of collateral to split\\n    function splitPosition(address _collateralToken, bytes32, bytes32 _conditionId, uint256[] calldata, uint256 _amount)\\n        external\\n    {\\n        if (_collateralToken != address(col)) revert UnexpectedCollateralToken();\\n        splitPosition(_conditionId, _amount);\\n    }\\n\\n    /// @notice Splits collateral to a complete set of conditional tokens for a single question\\n    /// @param _conditionId - the conditionId for the question\\n    /// @param _amount      - the amount of collateral to split\\n    function splitPosition(bytes32 _conditionId, uint256 _amount) public {\\n        col.safeTransferFrom(msg.sender, address(this), _amount);\\n        wcol.wrap(address(this), _amount);\\n        ctf.splitPosition(address(wcol), bytes32(0), _conditionId, Helpers.partition(), _amount);\\n        ctf.safeBatchTransferFrom(\\n            address(this), msg.sender, Helpers.positionIds(address(wcol), _conditionId), Helpers.values(2, _amount), \\\"\\\"\\n        );\\n\\n        emit PositionSplit(msg.sender, _conditionId, _amount);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            MERGE POSITIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Merges a complete set of conditional tokens for a single question to collateral\\n    /// @notice This function signature is the same as the CTF's mergePositions\\n    /// @param _collateralToken - the collateral token, must be the same as the adapter's collateral token\\n    /// @param _conditionId     - the conditionId for the question\\n    /// @param _amount          - the amount of collateral to merge\\n    function mergePositions(\\n        address _collateralToken,\\n        bytes32,\\n        bytes32 _conditionId,\\n        uint256[] calldata,\\n        uint256 _amount\\n    ) external {\\n        if (_collateralToken != address(col)) revert UnexpectedCollateralToken();\\n        mergePositions(_conditionId, _amount);\\n    }\\n\\n    /// @notice Merges a complete set of conditional tokens for a single question to collateral\\n    /// @param _conditionId - the conditionId for the question\\n    /// @param _amount      - the amount of collateral to merge\\n    function mergePositions(bytes32 _conditionId, uint256 _amount) public {\\n        uint256[] memory positionIds = Helpers.positionIds(address(wcol), _conditionId);\\n\\n        // get conditional tokens from sender\\n        ctf.safeBatchTransferFrom(msg.sender, address(this), positionIds, Helpers.values(2, _amount), \\\"\\\");\\n        ctf.mergePositions(address(wcol), bytes32(0), _conditionId, Helpers.partition(), _amount);\\n        wcol.unwrap(msg.sender, _amount);\\n\\n        emit PositionsMerge(msg.sender, _conditionId, _amount);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           ERC1155 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Proxies ERC1155 balanceOf to the CTF\\n    /// @param _owner   - the owner of the tokens\\n    /// @param _id      - the positionId\\n    /// @return balance - the owner's balance\\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256) {\\n        return ctf.balanceOf(_owner, _id);\\n    }\\n\\n    /// @notice Proxies ERC1155 balanceOfBatch to the CTF\\n    /// @param _owners   - the owners of the tokens\\n    /// @param _ids      - the positionIds\\n    /// @return balances - the owners' balances\\n    function balanceOfBatch(address[] memory _owners, uint256[] memory _ids) external view returns (uint256[] memory) {\\n        return ctf.balanceOfBatch(_owners, _ids);\\n    }\\n\\n    /// @notice Proxies ERC1155 safeTransferFrom to the CTF\\n    /// @notice Can only be called by an admin\\n    /// @notice Requires this contract to be approved for all\\n    /// @notice Requires the sender to be approved for all\\n    /// @param _from  - the owner of the tokens\\n    /// @param _to    - the recipient of the tokens\\n    /// @param _id    - the positionId\\n    /// @param _value - the amount of tokens to transfer\\n    /// @param _data  - the data to pass to the recipient\\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data)\\n        external\\n        onlyAdmin\\n    {\\n        if (!ctf.isApprovedForAll(_from, msg.sender)) {\\n            revert NotApprovedForAll();\\n        }\\n\\n        return ctf.safeTransferFrom(_from, _to, _id, _value, _data);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            REDEEM POSITION\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Redeem a set of conditional tokens for collateral\\n    /// @param _conditionId - conditionId of the conditional tokens to redeem\\n    /// @param _amounts     - amounts of conditional tokens to redeem\\n    /// _amounts should always have length 2, with the first element being the amount of yes tokens to redeem and the\\n    /// second element being the amount of no tokens to redeem\\n    function redeemPositions(bytes32 _conditionId, uint256[] calldata _amounts) public {\\n        uint256[] memory positionIds = Helpers.positionIds(address(wcol), _conditionId);\\n\\n        // get conditional tokens from sender\\n        ctf.safeBatchTransferFrom(msg.sender, address(this), positionIds, _amounts, \\\"\\\");\\n        ctf.redeemPositions(address(wcol), bytes32(0), _conditionId, Helpers.partition());\\n\\n        uint256 payout = wcol.balanceOf(address(this));\\n        if (payout > 0) {\\n            wcol.unwrap(msg.sender, payout);\\n        }\\n\\n        emit PayoutRedemption(msg.sender, _conditionId, _amounts, payout);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            CONVERT POSITIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Convert a set of no positions to the complementary set of yes positions plus collateral proportional to\\n    /// (# of no positions - 1)\\n    /// @notice If the market has a fee, the fee is taken from both collateral and the yes positions\\n    /// @param _marketId - the marketId\\n    /// @param _indexSet - the set of positions to convert, expressed as an index set where the least significant bit is\\n    /// the first question (index zero)\\n    /// @param _amount   - the amount of tokens to convert\\n    function convertPositions(bytes32 _marketId, uint256 _indexSet, uint256 _amount) external {\\n        MarketData md = getMarketData(_marketId);\\n        uint256 questionCount = md.questionCount();\\n\\n        if (md.oracle() == address(0)) revert MarketNotPrepared();\\n        if (questionCount <= 1) revert NoConvertiblePositions();\\n        if (_indexSet == 0) revert InvalidIndexSet();\\n        if ((_indexSet >> questionCount) > 0) revert InvalidIndexSet();\\n\\n        // if _amount is 0, return early\\n        if (_amount == 0) {\\n            return;\\n        }\\n\\n        uint256 index = 0;\\n        uint256 noPositionCount;\\n\\n        // count number of no positions\\n        while (index < questionCount) {\\n            unchecked {\\n                if ((_indexSet & (1 << index)) > 0) {\\n                    ++noPositionCount;\\n                }\\n                ++index;\\n            }\\n        }\\n\\n        uint256 yesPositionCount = questionCount - noPositionCount;\\n        uint256[] memory noPositionIds = new uint256[](noPositionCount);\\n        uint256[] memory yesPositionIds = new uint256[](yesPositionCount);\\n        uint256[] memory accumulatedNoPositionIds = new uint256[](yesPositionCount);\\n\\n        // mint the amount of wcol required\\n        wcol.mint(yesPositionCount * _amount);\\n\\n        // populate noPositionIds and yesPositionIds\\n        // split yes positions\\n        {\\n            uint256 noIndex;\\n            uint256 yesIndex;\\n            index = 0;\\n\\n            while (index < questionCount) {\\n                bytes32 questionId = NegRiskIdLib.getQuestionId(_marketId, uint8(index));\\n\\n                if ((_indexSet & (1 << index)) > 0) {\\n                    // NO\\n                    noPositionIds[noIndex] = getPositionId(questionId, false);\\n\\n                    unchecked {\\n                        ++noIndex;\\n                    }\\n                } else {\\n                    // YES\\n                    yesPositionIds[yesIndex] = getPositionId(questionId, true);\\n                    accumulatedNoPositionIds[yesIndex] = getPositionId(questionId, false);\\n\\n                    // split position to get yes and no tokens\\n                    // the no tokens will be discarded\\n                    _splitPosition(getConditionId(questionId), _amount);\\n\\n                    unchecked {\\n                        ++yesIndex;\\n                    }\\n                }\\n                unchecked {\\n                    ++index;\\n                }\\n            }\\n        }\\n\\n        // transfer the caller's no tokens _and_ accumulated no tokens to the burn address\\n        // these must never be redeemed\\n        {\\n            ctf.safeBatchTransferFrom(\\n                msg.sender, NO_TOKEN_BURN_ADDRESS, noPositionIds, Helpers.values(noPositionIds.length, _amount), \\\"\\\"\\n            );\\n            ctf.safeBatchTransferFrom(\\n                address(this),\\n                NO_TOKEN_BURN_ADDRESS,\\n                accumulatedNoPositionIds,\\n                Helpers.values(yesPositionCount, _amount),\\n                \\\"\\\"\\n            );\\n        }\\n\\n        uint256 feeAmount = (_amount * md.feeBips()) / FEE_DENOMINATOR;\\n        uint256 amountOut = _amount - feeAmount;\\n\\n        if (noPositionIds.length > 1) {\\n            // collateral out is always proportional to the number of no positions minus 1\\n            uint256 multiplier = noPositionIds.length - 1;\\n            // transfer collateral fees to vault\\n            if (feeAmount > 0) {\\n                wcol.release(vault, multiplier * feeAmount);\\n            }\\n            // transfer collateral to sender\\n            wcol.release(msg.sender, multiplier * amountOut);\\n        }\\n\\n        if (yesPositionIds.length > 0) {\\n            if (feeAmount > 0) {\\n                // transfer yes token fees to vault\\n                ctf.safeBatchTransferFrom(\\n                    address(this), vault, yesPositionIds, Helpers.values(yesPositionIds.length, feeAmount), \\\"\\\"\\n                );\\n            }\\n\\n            // transfer yes tokens to sender\\n            ctf.safeBatchTransferFrom(\\n                address(this), msg.sender, yesPositionIds, Helpers.values(yesPositionIds.length, amountOut), \\\"\\\"\\n            );\\n        }\\n\\n        emit PositionsConverted(msg.sender, _marketId, _indexSet, _amount);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             PREPARE MARKET\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Prepare a multi-outcome market\\n    /// @param _feeBips  - the fee for the market, out of 10_000\\n    /// @param _metadata     - metadata for the market\\n    /// @return marketId - the marketId\\n    function prepareMarket(uint256 _feeBips, bytes calldata _metadata) external returns (bytes32) {\\n        bytes32 marketId = _prepareMarket(_feeBips, _metadata);\\n\\n        emit MarketPrepared(marketId, msg.sender, _feeBips, _metadata);\\n\\n        return marketId;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            PREPARE QUESTION\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Prepare a question for a given market\\n    /// @param _marketId   - the id of the market for which to prepare the question\\n    /// @param _metadata   - the question metadata\\n    /// @return questionId - the id of the resulting question\\n    function prepareQuestion(bytes32 _marketId, bytes calldata _metadata) external returns (bytes32) {\\n        (bytes32 questionId, uint256 questionIndex) = _prepareQuestion(_marketId);\\n        bytes32 conditionId = getConditionId(questionId);\\n\\n        // check to see if the condition has already been prepared on the ctf\\n        if (ctf.getOutcomeSlotCount(conditionId) == 0) {\\n            ctf.prepareCondition(address(this), questionId, 2);\\n        }\\n\\n        emit QuestionPrepared(_marketId, questionId, questionIndex, _metadata);\\n\\n        return questionId;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             REPORT OUTCOME\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Report the outcome of a question\\n    /// @param _questionId - the questionId to report\\n    /// @param _outcome    - the outcome of the question\\n    function reportOutcome(bytes32 _questionId, bool _outcome) external {\\n        _reportOutcome(_questionId, _outcome);\\n\\n        ctf.reportPayouts(_questionId, Helpers.payouts(_outcome));\\n\\n        emit OutcomeReported(NegRiskIdLib.getMarketId(_questionId), _questionId, _outcome);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                INTERNAL\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev internal function to avoid stack too deep in convertPositions\\n    function _splitPosition(bytes32 _conditionId, uint256 _amount) internal {\\n        ctf.splitPosition(address(wcol), bytes32(0), _conditionId, Helpers.partition(), _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/modules/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {IAuth} from \\\"./interfaces/IAuth.sol\\\";\\n\\n/// @title Auth\\n/// @author Jon Amenechi (jon@polymarket.com)\\n/// @notice Provides access control modifiers\\nabstract contract Auth is IAuth {\\n    /// @notice Auth\\n    mapping(address => uint256) public admins;\\n\\n    modifier onlyAdmin() {\\n        if (admins[msg.sender] != 1) revert NotAdmin();\\n        _;\\n    }\\n\\n    constructor() {\\n        admins[msg.sender] = 1;\\n    }\\n\\n    /// @notice Adds an Admin\\n    /// @param admin - The address of the admin\\n    function addAdmin(address admin) external onlyAdmin {\\n        admins[admin] = 1;\\n        emit NewAdmin(msg.sender, admin);\\n    }\\n\\n    /// @notice Removes an admin\\n    /// @param admin - The address of the admin to be removed\\n    function removeAdmin(address admin) external onlyAdmin {\\n        admins[admin] = 0;\\n        emit RemovedAdmin(msg.sender, admin);\\n    }\\n\\n    /// @notice Renounces Admin privileges from the caller\\n    function renounceAdmin() external onlyAdmin {\\n        admins[msg.sender] = 0;\\n        emit RemovedAdmin(msg.sender, msg.sender);\\n    }\\n\\n    /// @notice Checks if an address is an admin\\n    /// @param addr - The address to be checked\\n    function isAdmin(address addr) external view returns (bool) {\\n        return admins[addr] == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/modules/interfaces/IAuth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\ninterface IAuthEE {\\n    error NotAdmin();\\n\\n    /// @notice Emitted when a new admin is added\\n    event NewAdmin(address indexed admin, address indexed newAdminAddress);\\n\\n    /// @notice Emitted when an admin is removed\\n    event RemovedAdmin(address indexed admin, address indexed removedAdmin);\\n}\\n\\ninterface IAuth is IAuthEE {\\n    function isAdmin(address) external view returns (bool);\\n\\n    function addAdmin(address) external;\\n\\n    function removeAdmin(address) external;\\n\\n    function renounceAdmin() external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/NegRiskIdLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/// @title NegRiskIdLib\\n/// @notice Functions for the NegRiskAdapter Market and QuestionIds\\n/// @notice MarketIds are the keccak256 hash of the oracle, feeBips, and metadata, with the final 8 bits set to 0\\n/// @notice QuestionIds share the first 31 bytes with their corresponding MarketId, and the final byte consists of the\\n/// questionIndex\\n/// @author Mike Shrieve (mike@polymarket.com)\\nlibrary NegRiskIdLib {\\n    bytes32 private constant MASK = bytes32(type(uint256).max) << 8;\\n\\n    /// @notice Returns the MarketId for a given oracle, feeBips, and metadata\\n    /// @param _oracle   - the oracle address\\n    /// @param _feeBips  - the feeBips, out of 10_000\\n    /// @param _metadata - the market metadata\\n    /// @return marketId - the marketId\\n    function getMarketId(address _oracle, uint256 _feeBips, bytes memory _metadata) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(_oracle, _feeBips, _metadata)) & MASK;\\n    }\\n\\n    /// @notice Returns the MarketId for a given QuestionId\\n    /// @param _questionId - the questionId\\n    /// @return marketId   - the marketId\\n    function getMarketId(bytes32 _questionId) internal pure returns (bytes32) {\\n        return _questionId & MASK;\\n    }\\n\\n    /// @notice Returns the QuestionId for a given MarketId and questionIndex\\n    /// @param _marketId      - the marketId\\n    /// @param _questionIndex - the questionIndex\\n    /// @return questionId    - the questionId\\n    function getQuestionId(bytes32 _marketId, uint8 _questionIndex) internal pure returns (bytes32) {\\n        unchecked {\\n            return bytes32(uint256(_marketId) + _questionIndex);\\n        }\\n    }\\n\\n    /// @notice Returns the questionIndex for a given QuestionId\\n    /// @param _questionId - the questionId\\n    /// @return questionIndex - the questionIndex\\n    function getQuestionIndex(bytes32 _questionId) internal pure returns (uint8) {\\n        return uint8(uint256(_questionId));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual {\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i = 0; i < ids.length; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        require(owners.length == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < owners.length; ++i) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/WrappedCollateral.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {ERC20} from \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\n\\n/// @title IWrappedCollateralEE\\n/// @notice WrappedCollateral Errors and Events\\ninterface IWrappedCollateralEE {\\n    error OnlyOwner();\\n}\\n\\nstring constant NAME = \\\"Wrapped Collateral\\\";\\nstring constant SYMBOL = \\\"WCOL\\\";\\n\\n/// @title WrappedCollateral\\n/// @author Mike Shrieve (mike@polymarket.com)\\n/// @notice Wraps an ERC20 token to be used as collateral in the CTF\\ncontract WrappedCollateral is IWrappedCollateralEE, ERC20 {\\n    using SafeTransferLib for ERC20;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 STATE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public immutable owner;\\n    address public immutable underlying;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               MODIFIERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    modifier onlyOwner() {\\n        if (msg.sender != owner) revert OnlyOwner();\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @param _underlying The address of the underlying ERC20 token\\n    /// @param _decimals The number of decimals of the underlying ERC20 token\\n    constructor(address _underlying, uint8 _decimals) ERC20(NAME, SYMBOL, _decimals) {\\n        owner = msg.sender;\\n        underlying = _underlying;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 UNWRAP\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Unwraps the specified amount of tokens\\n    /// @param _to The address to send the unwrapped tokens to\\n    /// @param _amount The amount of tokens to unwrap\\n    function unwrap(address _to, uint256 _amount) external {\\n        _burn(msg.sender, _amount);\\n        ERC20(underlying).safeTransfer(_to, _amount);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 ADMIN\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Wraps the specified amount of tokens\\n    /// @notice Can only be called by the owner\\n    /// @param _to     - the address to send the wrapped tokens to\\n    /// @param _amount - the amount of tokens to wrap\\n    function wrap(address _to, uint256 _amount) external onlyOwner {\\n        ERC20(underlying).safeTransferFrom(msg.sender, address(this), _amount);\\n        _mint(_to, _amount);\\n    }\\n\\n    /// @notice Burns the specified amount of tokens\\n    /// @notice Can only be called by the owner\\n    /// @param _amount - the amount of tokens to burn\\n    function burn(uint256 _amount) external onlyOwner {\\n        _burn(msg.sender, _amount);\\n    }\\n\\n    /// @notice Mints the specified amount of tokens\\n    /// @notice Can only be called by the owner\\n    /// @param _amount - the amount of tokens to mint\\n    function mint(uint256 _amount) external onlyOwner {\\n        _mint(msg.sender, _amount);\\n    }\\n\\n    /// @notice Releases the specified amount of the underlying token\\n    /// @notice Can only be called by the owner\\n    /// @param _to     - the address to send the released tokens to\\n    /// @param _amount - the amount of tokens to release\\n    function release(address _to, uint256 _amount) external onlyOwner {\\n        ERC20(underlying).safeTransfer(_to, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/modules/MarketDataManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {MarketData, MarketDataLib} from \\\"src/types/MarketData.sol\\\";\\nimport {NegRiskIdLib} from \\\"src/libraries/NegRiskIdLib.sol\\\";\\n\\ninterface IMarketStateManagerEE {\\n    error IndexOutOfBounds();\\n    error OnlyOracle();\\n    error MarketNotPrepared();\\n    error MarketAlreadyPrepared();\\n    error MarketAlreadyDetermined();\\n    error FeeBipsOutOfBounds();\\n}\\n\\n/// @title MarketStateManager\\n/// @notice Manages market state on behalf of the NegRiskAdapter\\n/// @author Mike Shrieve(mike@polymarket.com)\\nabstract contract MarketStateManager is IMarketStateManagerEE {\\n    mapping(bytes32 _marketId => MarketData) internal marketData;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                GETTERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function getMarketData(bytes32 _marketId) public view returns (MarketData) {\\n        return marketData[_marketId];\\n    }\\n\\n    function getOracle(bytes32 _marketId) external view returns (address) {\\n        return marketData[_marketId].oracle();\\n    }\\n\\n    function getQuestionCount(bytes32 _marketId) external view returns (uint256) {\\n        return marketData[_marketId].questionCount();\\n    }\\n\\n    function getDetermined(bytes32 _marketId) external view returns (bool) {\\n        return marketData[_marketId].determined();\\n    }\\n\\n    function getResult(bytes32 _marketId) external view returns (uint256) {\\n        return marketData[_marketId].result();\\n    }\\n\\n    function getFeeBips(bytes32 _marketId) external view returns (uint256) {\\n        return marketData[_marketId].feeBips();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                INTERNAL\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Prepares market data\\n    /// @notice The market id depends on the oracle address, feeBips, and market metadata\\n    /// @param _feeBips  - feeBips out of 10_000\\n    /// @param _metadata - market metadata\\n    /// @return marketId - the market id\\n    function _prepareMarket(uint256 _feeBips, bytes memory _metadata) internal returns (bytes32 marketId) {\\n        address oracle = msg.sender;\\n        marketId = NegRiskIdLib.getMarketId(oracle, _feeBips, _metadata);\\n        MarketData md = marketData[marketId];\\n\\n        if (md.oracle() != address(0)) revert MarketAlreadyPrepared();\\n        if (_feeBips > 10_000) revert FeeBipsOutOfBounds();\\n\\n        marketData[marketId] = MarketDataLib.initialize(oracle, _feeBips);\\n    }\\n\\n    /// @notice Prepares a new question for the given market\\n    /// @param _marketId   - the market for which to prepare a new question\\n    /// @return questionId - the resulting question id\\n    /// @return index      - the resulting question index\\n    function _prepareQuestion(bytes32 _marketId) internal returns (bytes32 questionId, uint256 index) {\\n        MarketData md = marketData[_marketId];\\n        address oracle = marketData[_marketId].oracle();\\n\\n        if (oracle == address(0)) revert MarketNotPrepared();\\n        if (oracle != msg.sender) revert OnlyOracle();\\n\\n        index = md.questionCount();\\n        questionId = NegRiskIdLib.getQuestionId(_marketId, uint8(index));\\n        marketData[_marketId] = md.incrementQuestionCount();\\n    }\\n\\n    /// @notice Reports the outcome of a question\\n    /// @notice State is only modified if the outcome is true\\n    /// @notice Reverts if the market is not prepared\\n    /// @notice Reverts if msg.sender is not the market's oracle\\n    /// @notice Reverts if the question index is out of bounds\\n    /// @notice Reverts if the outcome is true, and the market has already been determined\\n    function _reportOutcome(bytes32 _questionId, bool _outcome) internal {\\n        bytes32 marketId = NegRiskIdLib.getMarketId(_questionId);\\n        uint256 questionIndex = NegRiskIdLib.getQuestionIndex(_questionId);\\n\\n        MarketData data = marketData[marketId];\\n        address oracle = data.oracle();\\n\\n        if (oracle == address(0)) revert MarketNotPrepared();\\n        if (oracle != msg.sender) revert OnlyOracle();\\n        if (questionIndex >= data.questionCount()) revert IndexOutOfBounds();\\n\\n        if (_outcome == true) {\\n            if (data.determined()) revert MarketAlreadyDetermined();\\n            marketData[marketId] = data.determine(questionIndex);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/CTHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity >=0.5.1;\\n\\n// forked from Gnosis Condtional Tokens\\nlibrary CTHelpers {\\n    /// @dev Constructs a condition ID from an oracle, a question ID, and the outcome slot count for\\n    /// the question.\\n    /// @param oracle The account assigned to report the result for the prepared condition.\\n    /// @param questionId An identifier for the question to be answered by the oracle.\\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition.\\n    /// Must not exceed 256.\\n    function getConditionId(address oracle, bytes32 questionId, uint256 outcomeSlotCount)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount));\\n    }\\n\\n    uint256 constant P =\\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    uint256 constant B = 3;\\n\\n    function sqrt(uint256 x) private pure returns (uint256 y) {\\n        uint256 p = P;\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            // add chain generated via https://crypto.stackexchange.com/q/27179/71252\\n            // and transformed to the following program:\\n\\n            // x=1; y=x+x; z=y+y; z=z+z; y=y+z; x=x+y; y=y+x; z=y+y; t=z+z; t=z+t; t=t+t;\\n            // t=t+t; z=z+t; x=x+z; z=x+x; z=z+z; y=y+z; z=y+y; z=z+z; z=z+z; z=y+z; x=x+z;\\n            // z=x+x; z=z+z; z=z+z; z=x+z; y=y+z; x=x+y; z=x+x; z=z+z; y=y+z; z=y+y; t=z+z;\\n            // t=t+t; t=t+t; z=z+t; x=x+z; y=y+x; z=y+y; z=z+z; z=z+z; x=x+z; z=x+x; z=z+z;\\n            // z=x+z; z=z+z; z=z+z; z=x+z; y=y+z; z=y+y; t=z+z; t=t+t; t=z+t; t=y+t; t=t+t;\\n            // t=t+t; t=t+t; t=t+t; z=z+t; x=x+z; z=x+x; z=x+z; y=y+z; z=y+y; z=y+z; z=z+z;\\n            // t=z+z; t=z+t; w=t+t; w=w+w; w=w+w; w=w+w; w=w+w; t=t+w; z=z+t; x=x+z; y=y+x;\\n            // z=y+y; x=x+z; y=y+x; x=x+y; y=y+x; x=x+y; z=x+x; z=x+z; z=z+z; y=y+z; z=y+y;\\n            // z=z+z; x=x+z; y=y+x; z=y+y; z=y+z; x=x+z; y=y+x; x=x+y; y=y+x; z=y+y; z=z+z;\\n            // z=y+z; x=x+z; z=x+x; z=x+z; y=y+z; x=x+y; y=y+x; x=x+y; y=y+x; z=y+y; z=y+z;\\n            // z=z+z; x=x+z; y=y+x; z=y+y; z=y+z; z=z+z; x=x+z; z=x+x; t=z+z; t=t+t; t=z+t;\\n            // t=x+t; t=t+t; t=t+t; t=t+t; t=t+t; z=z+t; y=y+z; x=x+y; y=y+x; x=x+y; z=x+x;\\n            // z=x+z; z=z+z; z=z+z; z=z+z; z=x+z; y=y+z; z=y+y; z=y+z; z=z+z; x=x+z; z=x+x;\\n            // z=x+z; y=y+z; x=x+y; z=x+x; z=z+z; y=y+z; x=x+y; z=x+x; y=y+z; x=x+y; y=y+x;\\n            // z=y+y; z=y+z; x=x+z; y=y+x; z=y+y; z=y+z; z=z+z; z=z+z; x=x+z; z=x+x; z=z+z;\\n            // z=z+z; z=x+z; y=y+z; x=x+y; z=x+x; t=x+z; t=t+t; t=t+t; z=z+t; y=y+z; z=y+y;\\n            // x=x+z; y=y+x; x=x+y; y=y+x; x=x+y; y=y+x; z=y+y; t=y+z; z=y+t; z=z+z; z=z+z;\\n            // z=t+z; x=x+z; y=y+x; x=x+y; y=y+x; x=x+y; z=x+x; z=x+z; y=y+z; x=x+y; x=x+x;\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\\n            // x=x+x; x=x+x; x=x+x; x=x+x; res=y+x\\n            // res == (P + 1) // 4\\n\\n            y := mulmod(x, x, p)\\n            {\\n                let z := mulmod(y, y, p)\\n                z := mulmod(z, z, p)\\n                y := mulmod(y, z, p)\\n                x := mulmod(x, y, p)\\n                y := mulmod(y, x, p)\\n                z := mulmod(y, y, p)\\n                {\\n                    let t := mulmod(z, z, p)\\n                    t := mulmod(z, t, p)\\n                    t := mulmod(t, t, p)\\n                    t := mulmod(t, t, p)\\n                    z := mulmod(z, t, p)\\n                    x := mulmod(x, z, p)\\n                    z := mulmod(x, x, p)\\n                    z := mulmod(z, z, p)\\n                    y := mulmod(y, z, p)\\n                    z := mulmod(y, y, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(y, z, p)\\n                    x := mulmod(x, z, p)\\n                    z := mulmod(x, x, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(x, z, p)\\n                    y := mulmod(y, z, p)\\n                    x := mulmod(x, y, p)\\n                    z := mulmod(x, x, p)\\n                    z := mulmod(z, z, p)\\n                    y := mulmod(y, z, p)\\n                    z := mulmod(y, y, p)\\n                    t := mulmod(z, z, p)\\n                    t := mulmod(t, t, p)\\n                    t := mulmod(t, t, p)\\n                    z := mulmod(z, t, p)\\n                    x := mulmod(x, z, p)\\n                    y := mulmod(y, x, p)\\n                    z := mulmod(y, y, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(z, z, p)\\n                    x := mulmod(x, z, p)\\n                    z := mulmod(x, x, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(x, z, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(x, z, p)\\n                    y := mulmod(y, z, p)\\n                    z := mulmod(y, y, p)\\n                    t := mulmod(z, z, p)\\n                    t := mulmod(t, t, p)\\n                    t := mulmod(z, t, p)\\n                    t := mulmod(y, t, p)\\n                    t := mulmod(t, t, p)\\n                    t := mulmod(t, t, p)\\n                    t := mulmod(t, t, p)\\n                    t := mulmod(t, t, p)\\n                    z := mulmod(z, t, p)\\n                    x := mulmod(x, z, p)\\n                    z := mulmod(x, x, p)\\n                    z := mulmod(x, z, p)\\n                    y := mulmod(y, z, p)\\n                    z := mulmod(y, y, p)\\n                    z := mulmod(y, z, p)\\n                    z := mulmod(z, z, p)\\n                    t := mulmod(z, z, p)\\n                    t := mulmod(z, t, p)\\n                    {\\n                        let w := mulmod(t, t, p)\\n                        w := mulmod(w, w, p)\\n                        w := mulmod(w, w, p)\\n                        w := mulmod(w, w, p)\\n                        w := mulmod(w, w, p)\\n                        t := mulmod(t, w, p)\\n                    }\\n                    z := mulmod(z, t, p)\\n                    x := mulmod(x, z, p)\\n                    y := mulmod(y, x, p)\\n                    z := mulmod(y, y, p)\\n                    x := mulmod(x, z, p)\\n                    y := mulmod(y, x, p)\\n                    x := mulmod(x, y, p)\\n                    y := mulmod(y, x, p)\\n                    x := mulmod(x, y, p)\\n                    z := mulmod(x, x, p)\\n                    z := mulmod(x, z, p)\\n                    z := mulmod(z, z, p)\\n                    y := mulmod(y, z, p)\\n                    z := mulmod(y, y, p)\\n                    z := mulmod(z, z, p)\\n                    x := mulmod(x, z, p)\\n                    y := mulmod(y, x, p)\\n                    z := mulmod(y, y, p)\\n                    z := mulmod(y, z, p)\\n                    x := mulmod(x, z, p)\\n                    y := mulmod(y, x, p)\\n                    x := mulmod(x, y, p)\\n                    y := mulmod(y, x, p)\\n                    z := mulmod(y, y, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(y, z, p)\\n                    x := mulmod(x, z, p)\\n                    z := mulmod(x, x, p)\\n                    z := mulmod(x, z, p)\\n                    y := mulmod(y, z, p)\\n                    x := mulmod(x, y, p)\\n                    y := mulmod(y, x, p)\\n                    x := mulmod(x, y, p)\\n                    y := mulmod(y, x, p)\\n                    z := mulmod(y, y, p)\\n                    z := mulmod(y, z, p)\\n                    z := mulmod(z, z, p)\\n                    x := mulmod(x, z, p)\\n                    y := mulmod(y, x, p)\\n                    z := mulmod(y, y, p)\\n                    z := mulmod(y, z, p)\\n                    z := mulmod(z, z, p)\\n                    x := mulmod(x, z, p)\\n                    z := mulmod(x, x, p)\\n                    t := mulmod(z, z, p)\\n                    t := mulmod(t, t, p)\\n                    t := mulmod(z, t, p)\\n                    t := mulmod(x, t, p)\\n                    t := mulmod(t, t, p)\\n                    t := mulmod(t, t, p)\\n                    t := mulmod(t, t, p)\\n                    t := mulmod(t, t, p)\\n                    z := mulmod(z, t, p)\\n                    y := mulmod(y, z, p)\\n                    x := mulmod(x, y, p)\\n                    y := mulmod(y, x, p)\\n                    x := mulmod(x, y, p)\\n                    z := mulmod(x, x, p)\\n                    z := mulmod(x, z, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(x, z, p)\\n                    y := mulmod(y, z, p)\\n                    z := mulmod(y, y, p)\\n                    z := mulmod(y, z, p)\\n                    z := mulmod(z, z, p)\\n                    x := mulmod(x, z, p)\\n                    z := mulmod(x, x, p)\\n                    z := mulmod(x, z, p)\\n                    y := mulmod(y, z, p)\\n                    x := mulmod(x, y, p)\\n                    z := mulmod(x, x, p)\\n                    z := mulmod(z, z, p)\\n                    y := mulmod(y, z, p)\\n                    x := mulmod(x, y, p)\\n                    z := mulmod(x, x, p)\\n                    y := mulmod(y, z, p)\\n                    x := mulmod(x, y, p)\\n                    y := mulmod(y, x, p)\\n                    z := mulmod(y, y, p)\\n                    z := mulmod(y, z, p)\\n                    x := mulmod(x, z, p)\\n                    y := mulmod(y, x, p)\\n                    z := mulmod(y, y, p)\\n                    z := mulmod(y, z, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(z, z, p)\\n                    x := mulmod(x, z, p)\\n                    z := mulmod(x, x, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(x, z, p)\\n                    y := mulmod(y, z, p)\\n                    x := mulmod(x, y, p)\\n                    z := mulmod(x, x, p)\\n                    t := mulmod(x, z, p)\\n                    t := mulmod(t, t, p)\\n                    t := mulmod(t, t, p)\\n                    z := mulmod(z, t, p)\\n                    y := mulmod(y, z, p)\\n                    z := mulmod(y, y, p)\\n                    x := mulmod(x, z, p)\\n                    y := mulmod(y, x, p)\\n                    x := mulmod(x, y, p)\\n                    y := mulmod(y, x, p)\\n                    x := mulmod(x, y, p)\\n                    y := mulmod(y, x, p)\\n                    z := mulmod(y, y, p)\\n                    t := mulmod(y, z, p)\\n                    z := mulmod(y, t, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(z, z, p)\\n                    z := mulmod(t, z, p)\\n                }\\n                x := mulmod(x, z, p)\\n                y := mulmod(y, x, p)\\n                x := mulmod(x, y, p)\\n                y := mulmod(y, x, p)\\n                x := mulmod(x, y, p)\\n                z := mulmod(x, x, p)\\n                z := mulmod(x, z, p)\\n                y := mulmod(y, z, p)\\n            }\\n            x := mulmod(x, y, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            x := mulmod(x, x, p)\\n            y := mulmod(y, x, p)\\n        }\\n    }\\n\\n    /// @dev Constructs an outcome collection ID from a parent collection and an outcome collection.\\n    /// @param parentCollectionId Collection ID of the parent outcome collection, or bytes32(0) if\\n    /// there's no parent.\\n    /// @param conditionId Condition ID of the outcome collection to combine with the parent outcome\\n    /// collection.\\n    /// @param indexSet Index set of the outcome collection to combine with the parent outcome\\n    /// collection.\\n    function getCollectionId(bytes32 parentCollectionId, bytes32 conditionId, uint256 indexSet)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        uint256 x1 = uint256(keccak256(abi.encodePacked(conditionId, indexSet)));\\n        bool odd = x1 >> 255 != 0;\\n        uint256 y1;\\n        uint256 yy;\\n        do {\\n            x1 = addmod(x1, 1, P);\\n            yy = addmod(mulmod(x1, mulmod(x1, x1, P), P), B, P);\\n            y1 = sqrt(yy);\\n        } while (mulmod(y1, y1, P) != yy);\\n        if ((odd && y1 % 2 == 0) || (!odd && y1 % 2 == 1)) y1 = P - y1;\\n\\n        uint256 x2 = uint256(parentCollectionId);\\n        if (x2 != 0) {\\n            odd = x2 >> 254 != 0;\\n            x2 = (x2 << 2) >> 2;\\n            yy = addmod(mulmod(x2, mulmod(x2, x2, P), P), B, P);\\n            uint256 y2 = sqrt(yy);\\n            if ((odd && y2 % 2 == 0) || (!odd && y2 % 2 == 1)) y2 = P - y2;\\n            require(mulmod(y2, y2, P) == yy, \\\"invalid parent collection ID\\\");\\n\\n            (bool success, bytes memory ret) = address(6).staticcall(abi.encode(x1, y1, x2, y2));\\n            require(success, \\\"ecadd failed\\\");\\n            (x1, y1) = abi.decode(ret, (uint256, uint256));\\n        }\\n\\n        if (y1 % 2 == 1) x1 ^= 1 << 254;\\n\\n        return bytes32(x1);\\n    }\\n\\n    /// @dev Constructs a position ID from a collateral token and an outcome collection. These IDs\\n    /// are used as the ERC-1155 ID for this contract.\\n    /// @param collateralToken Collateral token which backs the position.\\n    /// @param collectionId ID of the outcome collection associated with this position.\\n    function getPositionId(address collateralToken, bytes32 collectionId)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return uint256(keccak256(abi.encodePacked(collateralToken, collectionId)));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {CTHelpers} from \\\"./CTHelpers.sol\\\";\\n\\n/// @title Helpers\\n/// @notice Helper functions for the NegRiskAdapter\\n/// @author Mike Shrieve (mike@polymarket.com)\\nlibrary Helpers {\\n    /// @notice Returns the positionIds corresponding to _conditionId\\n    /// @param _collateral  - the collateral address\\n    /// @param _conditionId - the conditionId\\n    /// @return positionIds - length 2 array of position ids\\n    function positionIds(address _collateral, bytes32 _conditionId) internal view returns (uint256[] memory) {\\n        uint256[] memory positionIds_ = new uint256[](2);\\n\\n        // YES\\n        positionIds_[0] = CTHelpers.getPositionId(_collateral, CTHelpers.getCollectionId(bytes32(0), _conditionId, 1));\\n        // NO\\n        positionIds_[1] = CTHelpers.getPositionId(_collateral, CTHelpers.getCollectionId(bytes32(0), _conditionId, 2));\\n\\n        return positionIds_;\\n    }\\n\\n    /// @notice Returns an array with each element set to the same value\\n    /// @param _length  - the length of the array\\n    /// @param _value   - the value of each element\\n    /// @return values_ - the array of values\\n    function values(uint256 _length, uint256 _value) internal pure returns (uint256[] memory) {\\n        uint256[] memory values_ = new uint256[](_length);\\n        uint256 i;\\n\\n        while (i < _length) {\\n            values_[i] = _value;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return values_;\\n    }\\n\\n    /// @notice returns the partition for a binary conditional token\\n    /// @return partition - the partition [1,2] = [0b01, 0b10]\\n    function partition() internal pure returns (uint256[] memory) {\\n        uint256[] memory partition_ = new uint256[](2);\\n        // YES\\n        partition_[0] = 1;\\n        // NO\\n        partition_[1] = 2;\\n        return partition_;\\n    }\\n\\n    /// @notice returns the payouts for a binary conditional token\\n    /// @notice payouts are [1,0] if _outcome is true and [0,1] otherwise\\n    /// @param _outcome - the boolean outcome\\n    /// @return payouts - the payouts\\n    function payouts(bool _outcome) internal pure returns (uint256[] memory) {\\n        uint256[] memory payouts_ = new uint256[](2);\\n        // YES\\n        payouts_[0] = _outcome ? 1 : 0;\\n        // NO\\n        payouts_[1] = _outcome ? 0 : 1;\\n        return payouts_;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IConditionalTokens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/// @notice references to IERC20 are replaced by address\\n\\n/// @notice Interface for Gnosis Conditional Tokens\\ninterface IERC1155 {\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    event TransferBatch(\\n        address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\\n\\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids) external view returns (uint256[] memory);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IConditionalTokensEE {\\n    event ConditionPreparation(\\n        bytes32 indexed conditionId, address indexed oracle, bytes32 indexed questionId, uint256 outcomeSlotCount\\n    );\\n\\n    event ConditionResolution(\\n        bytes32 indexed conditionId,\\n        address indexed oracle,\\n        bytes32 indexed questionId,\\n        uint256 outcomeSlotCount,\\n        uint256[] payoutNumerators\\n    );\\n\\n    /// @dev Emitted when a position is successfully split.\\n    event PositionSplit(\\n        address indexed stakeholder,\\n        address collateralToken,\\n        bytes32 indexed parentCollectionId,\\n        bytes32 indexed conditionId,\\n        uint256[] partition,\\n        uint256 amount\\n    );\\n    /// @dev Emitted when positions are successfully merged.\\n    event PositionsMerge(\\n        address indexed stakeholder,\\n        address collateralToken,\\n        bytes32 indexed parentCollectionId,\\n        bytes32 indexed conditionId,\\n        uint256[] partition,\\n        uint256 amount\\n    );\\n    event PayoutRedemption(\\n        address indexed redeemer,\\n        address indexed collateralToken,\\n        bytes32 indexed parentCollectionId,\\n        bytes32 conditionId,\\n        uint256[] indexSets,\\n        uint256 payout\\n    );\\n}\\n\\ninterface IConditionalTokens is IConditionalTokensEE, IERC1155 {\\n    function payoutNumerators(bytes32 conditionId, uint256 index) external view returns (uint256);\\n\\n    function payoutDenominator(bytes32 conditionId) external view returns (uint256);\\n\\n    /// @dev This function prepares a condition by initializing a payout vector associated with the\\n    /// condition.\\n    /// @param oracle The account assigned to report the result for the prepared condition.\\n    /// @param questionId An identifier for the question to be answered by the oracle.\\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition.\\n    /// Must not exceed 256.\\n    function prepareCondition(address oracle, bytes32 questionId, uint256 outcomeSlotCount) external;\\n\\n    /// @dev Called by the oracle for reporting results of conditions. Will set the payout vector\\n    /// for the condition with the ID ``keccak256(abi.encodePacked(oracle, questionId,\\n    /// outcomeSlotCount))``, where oracle is the message sender, questionId is one of the\\n    /// parameters of this function, and outcomeSlotCount is the length of the payouts parameter,\\n    /// which contains the payoutNumerators for each outcome slot of the condition.\\n    /// @param questionId The question ID the oracle is answering for\\n    /// @param payouts The oracle's answer\\n    function reportPayouts(bytes32 questionId, uint256[] calldata payouts) external;\\n\\n    /// @dev This function splits a position. If splitting from the collateral, this contract will\\n    /// attempt to transfer `amount` collateral from the message sender to itself. Otherwise, this\\n    /// contract will burn `amount` stake held by the message sender in the position being split\\n    /// worth of EIP 1155 tokens. Regardless, if successful, `amount` stake will be minted in the\\n    /// split target positions. If any of the transfers, mints, or burns fail, the transaction will\\n    /// revert. The transaction will also revert if the given partition is trivial, invalid, or\\n    /// refers to more slots than the condition is prepared with.\\n    /// @param collateralToken The address of the positions' backing collateral token.\\n    /// @param parentCollectionId The ID of the outcome collections common to the position being\\n    /// split and the split target positions. May be null, in which only the collateral is shared.\\n    /// @param conditionId The ID of the condition to split on.\\n    /// @param partition An array of disjoint index sets representing a nontrivial partition of the\\n    /// outcome slots of the given condition. E.g. A|B and C but not A|B and B|C (is not disjoint).\\n    /// Each element's a number which, together with the condition, represents the outcome\\n    /// collection. E.g. 0b110 is A|B, 0b010 is B, etc.\\n    /// @param amount The amount of collateral or stake to split.\\n    function splitPosition(\\n        address collateralToken,\\n        bytes32 parentCollectionId,\\n        bytes32 conditionId,\\n        uint256[] calldata partition,\\n        uint256 amount\\n    ) external;\\n\\n    function mergePositions(\\n        address collateralToken,\\n        bytes32 parentCollectionId,\\n        bytes32 conditionId,\\n        uint256[] calldata partition,\\n        uint256 amount\\n    ) external;\\n\\n    function redeemPositions(\\n        address collateralToken,\\n        bytes32 parentCollectionId,\\n        bytes32 conditionId,\\n        uint256[] calldata indexSets\\n    ) external;\\n\\n    /// @dev Gets the outcome slot count of a condition.\\n    /// @param conditionId ID of the condition.\\n    /// @return Number of outcome slots associated with a condition, or zero if condition has not\\n    /// been prepared yet.\\n    function getOutcomeSlotCount(bytes32 conditionId) external view returns (uint256);\\n\\n    /// @dev Constructs a condition ID from an oracle, a question ID, and the outcome slot count for\\n    /// the question.\\n    /// @param oracle The account assigned to report the result for the prepared condition.\\n    /// @param questionId An identifier for the question to be answered by the oracle.\\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition.\\n    /// Must not exceed 256.\\n    function getConditionId(address oracle, bytes32 questionId, uint256 outcomeSlotCount)\\n        external\\n        pure\\n        returns (bytes32);\\n\\n    /// @dev Constructs an outcome collection ID from a parent collection and an outcome collection.\\n    /// @param parentCollectionId Collection ID of the parent outcome collection, or bytes32(0) if\\n    /// there's no parent.\\n    /// @param conditionId Condition ID of the outcome collection to combine with the parent outcome\\n    /// collection.\\n    /// @param indexSet Index set of the outcome collection to combine with the parent outcome\\n    /// collection.\\n    function getCollectionId(bytes32 parentCollectionId, bytes32 conditionId, uint256 indexSet)\\n        external\\n        view\\n        returns (bytes32);\\n\\n    /// @dev Constructs a position ID from a collateral token and an outcome collection. These IDs\\n    /// are used as the ERC-1155 ID for this contract.\\n    /// @param collateralToken Collateral token which backs the position.\\n    /// @param collectionId ID of the outcome collection associated with this position.\\n    function getPositionId(address collateralToken, bytes32 collectionId) external pure returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/types/MarketData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/// @notice the MarketData user-defined type, a zero-cost abstraction over bytes32\\ntype MarketData is bytes32;\\n\\n// md[0] = questionCount\\n// md[1] = determined\\n// md[2] = result\\n// md[3:4] = feeBips\\n// md[12:32] = oracle\\n\\nusing MarketDataLib for MarketData global;\\n\\n/// @title MarketDataLib\\n/// @notice Library for dealing with the MarketData user-defined bytes32 type\\n/// @author Mike Shrieve (mike@polymarket.com)\\nlibrary MarketDataLib {\\n    error DeterminedFlagAlreadySet();\\n\\n    /// @notice used to increment the questionCount\\n    uint256 constant INCREMENT = uint256(bytes32(bytes1(0x01)));\\n\\n    /// @notice extracts the oracle address from MarketData\\n    /// @return oracle - the address of the oracle\\n    function oracle(MarketData _data) internal pure returns (address) {\\n        return address(uint160(uint256(MarketData.unwrap(_data))));\\n    }\\n\\n    /// @notice extracts the questionCount from MarketData\\n    /// @return questionCount - the number of questions in the market\\n    function questionCount(MarketData _data) internal pure returns (uint256) {\\n        return uint256(uint8(MarketData.unwrap(_data)[0]));\\n    }\\n\\n    /// @notice increments the questionCount\\n    /// @notice does _not_ check to see if the questionCount is already at the maximum value\\n    /// @return marketData - the modified MarketData\\n    function incrementQuestionCount(MarketData _data) internal pure returns (MarketData) {\\n        bytes32 data = MarketData.unwrap(_data);\\n        data = bytes32(uint256(data) + INCREMENT);\\n        return MarketData.wrap(data);\\n    }\\n\\n    /// @notice extracts the determined flag from MarketData\\n    /// @return determined - true if the market has been determined, i.e. if one of the questions was resolved true\\n    function determined(MarketData _data) internal pure returns (bool) {\\n        return MarketData.unwrap(_data)[1] == 0x00 ? false : true;\\n    }\\n\\n    /// @notice marks the market as determined\\n    /// @param _result - the result of the market, i.e., the index of the question that was resolved true\\n    /// @return marketData - the modified MarketData\\n    function determine(MarketData _data, uint256 _result) internal pure returns (MarketData) {\\n        bytes32 data = MarketData.unwrap(_data);\\n\\n        if (data[1] != 0x00) revert DeterminedFlagAlreadySet();\\n        data |= bytes32(bytes1(0x01)) >> 8;\\n        data |= bytes32(bytes1(uint8(_result))) >> 16;\\n\\n        return MarketData.wrap(data);\\n    }\\n\\n    /// @notice initializes the MarketData type\\n    /// @param _oracle - the address of the oracle\\n    /// @param _feeBips - the feeBips, out of 10_000\\n    /// @return marketData - the initialized MarketData\\n    function initialize(address _oracle, uint256 _feeBips) internal pure returns (MarketData) {\\n        bytes32 data;\\n        data |= bytes32(bytes2(uint16(_feeBips))) >> 24;\\n        data |= bytes32(uint256(uint160(_oracle)));\\n        return MarketData.wrap(data);\\n    }\\n\\n    /// @notice extracts the result from MarketData, i.e., the index of the question that was resolved true\\n    /// @notice if the market has not been determined, returns zero\\n    /// @return result - the index of the question that was resolved true, or zero\\n    function result(MarketData _data) internal pure returns (uint256) {\\n        return uint256(uint8(MarketData.unwrap(_data)[2]));\\n    }\\n\\n    /// @notice extracts the feeBips from MarketData, out of 10_000\\n    /// @return feeBips - the feeBips\\n    function feeBips(MarketData _data) internal pure returns (uint256) {\\n        return uint256(uint16(bytes2(MarketData.unwrap(_data) << 24)));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"forge-gas-snapshot/=lib/forge-gas-snapshot/src/\",\r\n      \"openzeppelin-contracts/=lib/ctf-exchange/lib/openzeppelin-contracts/contracts/\",\r\n      \"common/=lib/ctf-exchange/src/common/\",\r\n      \"creator/=lib/ctf-exchange/src/creator/\",\r\n      \"ctf-exchange/=lib/ctf-exchange/src/\",\r\n      \"dev/=lib/ctf-exchange/src/dev/\",\r\n      \"exchange-fee-module/=lib/exchange-fee-module/src/\",\r\n      \"exchange/=lib/ctf-exchange/src/exchange/\",\r\n      \"openzeppelin/=lib/ctf-exchange/lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nrAdapter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DelayPeriodNotOver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPayouts\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRequestId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEligibleForEmergencyResolution\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyFlagged\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyNegRiskAdapter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyNotFlagged\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOracle\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OracleAlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QuestionAlreadyReported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QuestionWithRequestIdAlreadyPrepared\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ResultNotAvailable\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"marketId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeBips\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MarketPrepared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdminAddress\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"questionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"name\":\"QuestionEmergencyResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"questionId\",\"type\":\"bytes32\"}],\"name\":\"QuestionFlagged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"marketId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"questionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"questionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"QuestionPrepared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"questionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"name\":\"QuestionReported\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"questionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"name\":\"QuestionResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"questionId\",\"type\":\"bytes32\"}],\"name\":\"QuestionUnflagged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"removedAdmin\",\"type\":\"address\"}],\"name\":\"RemovedAdmin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DELAY_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_questionId\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_result\",\"type\":\"bool\"}],\"name\":\"emergencyResolveQuestion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_questionId\",\"type\":\"bytes32\"}],\"name\":\"flagQuestion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_questionId\",\"type\":\"bytes32\"}],\"name\":\"flaggedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nrAdapter\",\"outputs\":[{\"internalType\":\"contract NegRiskAdapter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"prepareCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeBips\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"prepareMarket\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_marketId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_requestId\",\"type\":\"bytes32\"}],\"name\":\"prepareQuestion\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestId\",\"type\":\"bytes32\"}],\"name\":\"questionIds\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"_payouts\",\"type\":\"uint256[]\"}],\"name\":\"reportPayouts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_questionId\",\"type\":\"bytes32\"}],\"name\":\"reportedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_questionId\",\"type\":\"bytes32\"}],\"name\":\"resolveQuestion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_questionId\",\"type\":\"bytes32\"}],\"name\":\"results\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_questionId\",\"type\":\"bytes32\"}],\"name\":\"unflagQuestion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NegRiskOperator","CompilerVersion":"v0.8.19+commit.7dd6d404","CompilerType":"solc-j","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"000000000000000000000000d91e80cf2e7be2e162c6513ced06f1dd0da35296","EVMVersion":"paris","Library":"","ContractFileName":"src/NegRiskOperator.sol","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":"","SimilarMatch":""}]}