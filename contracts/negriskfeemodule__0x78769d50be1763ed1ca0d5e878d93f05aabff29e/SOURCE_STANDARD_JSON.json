{
  "language": "Solidity",
  "sources": {
    "src/NegRiskFeeModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {FeeModule, IExchange} from \"../lib/exchange-fee-module/src/FeeModule.sol\";\nimport {IConditionalTokens} from \"./interfaces/IConditionalTokens.sol\";\n\n/// @title NegRiskFeeModule\n/// @notice A slightly modified version of FeeModule\n/// @notice with added approvals for the NegRiskAdapter\ncontract NegRiskFeeModule is FeeModule {\n    constructor(address _negRiskCtfExchange, address _negRiskAdapter, address _ctf) FeeModule(_negRiskCtfExchange) {\n        IConditionalTokens(_ctf).setApprovalForAll(_negRiskAdapter, true);\n        IConditionalTokens(_ctf).setApprovalForAll(address(this), true);\n    }\n}\n"
    },
    "lib/exchange-fee-module/src/FeeModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC1155TokenReceiver } from \"solmate/tokens/ERC1155.sol\";\n\nimport { Auth } from \"./mixins/Auth.sol\";\nimport { Transfers } from \"./mixins/Transfers.sol\";\n\nimport { IExchange } from \"./interfaces/IExchange.sol\";\nimport { IFeeModule } from \"./interfaces/IFeeModule.sol\";\n\nimport { Order, Side } from \"./libraries/Structs.sol\";\nimport { CalculatorHelper } from \"./libraries/CalculatorHelper.sol\";\n\n/// @title Polymarket CTF Fee Module\n/// @notice Proxies the CTFExchange contract and refunds maker orders\n/// @author Jon Amenechi (jon@polymarket.com)\ncontract FeeModule is IFeeModule, Auth, Transfers, ERC1155TokenReceiver {\n    /// @notice The Exchange contract\n    IExchange public immutable exchange;\n\n    /// @notice The Collateral token\n    address public immutable collateral;\n\n    /// @notice The CTF contract\n    address public immutable ctf;\n\n    constructor(address _exchange) {\n        exchange = IExchange(_exchange);\n        collateral = exchange.getCollateral();\n        ctf = exchange.getCtf();\n    }\n\n    /// @notice Matches a taker order against a list of maker orders, refunding maker order fees if necessary\n    /// @param takerOrder       - The active order to be matched\n    /// @param makerOrders      - The array of maker orders to be matched against the active order\n    /// @param takerFillAmount  - The amount to fill on the taker order, always in terms of the maker amount\n    /// @param makerFillAmounts - The array of amounts to fill on the maker orders, always in terms of the maker amount\n    /// @param makerFeeRate     - The fee rate to be charged to maker orders\n    function matchOrders(\n        Order memory takerOrder,\n        Order[] memory makerOrders,\n        uint256 takerFillAmount,\n        uint256[] memory makerFillAmounts,\n        uint256 makerFeeRate\n    ) external onlyAdmin {\n        // Match the orders on the exchange\n        exchange.matchOrders(takerOrder, makerOrders, takerFillAmount, makerFillAmounts);\n\n        // Refund maker fees\n        _refundFees(makerOrders, makerFillAmounts, makerFeeRate);\n    }\n\n    /// @notice Withdraw collected fees\n    /// @param id       - The tokenID to be withdrawn. If 0, will be the collateral token.\n    /// @param amount   - The amount to be withdrawn\n    function withdrawFees(address to, uint256 id, uint256 amount) external onlyAdmin {\n        address token = id == 0 ? collateral : ctf;\n        _transfer(token, address(this), to, id, amount);\n        emit FeeWithdrawn(token, to, id, amount);\n    }\n\n    /// @notice Refund fees for a set of orders\n    /// @param orders       - The array of orders\n    /// @param fillAmounts  - The array of fill amounts for the orders\n    /// @param feeRate      - The fee rate to be charged to maker orders\n    function _refundFees(Order[] memory orders, uint256[] memory fillAmounts, uint256 feeRate) internal {\n        uint256 length = orders.length;\n        uint256 i = 0;\n        for (; i < length;) {\n            if(orders[i].feeRateBps > feeRate) {\n                _refundFee(orders[i], fillAmounts[i], feeRate);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Refund fee for an order\n    /// @param order        - The order\n    /// @param fillAmount   - The fill amount for the order\n    /// @param feeRate      - The fee rate to be charged to maker orders\n    function _refundFee(Order memory order, uint256 fillAmount, uint256 feeRate) internal {\n        // Calculate refund for the order, if any\n        uint256 refund = CalculatorHelper.calcRefund(\n            order.feeRateBps,\n            feeRate,\n            order.side == Side.BUY ? CalculatorHelper.calculateTakingAmount(fillAmount, order.makerAmount, order.takerAmount) : fillAmount,\n            order.makerAmount,\n            order.takerAmount,\n            order.side\n        );\n\n        uint256 id = order.side == Side.BUY ? order.tokenId : 0;\n        address token = order.side == Side.BUY ? ctf : collateral;\n\n        // If the refund is non-zero, transfer it to the order maker\n        if (refund > 0) {\n            _transfer(token, address(this), order.maker, id, refund);\n            emit FeeRefunded(token, order.maker, id, refund);\n        }\n    }\n}\n"
    },
    "src/interfaces/IConditionalTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/// @notice references to IERC20 are replaced by address\n\n/// @notice Interface for Gnosis Conditional Tokens\ninterface IERC1155 {\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    event TransferBatch(\n        address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids) external view returns (uint256[] memory);\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n\ninterface IConditionalTokensEE {\n    event ConditionPreparation(\n        bytes32 indexed conditionId, address indexed oracle, bytes32 indexed questionId, uint256 outcomeSlotCount\n    );\n\n    event ConditionResolution(\n        bytes32 indexed conditionId,\n        address indexed oracle,\n        bytes32 indexed questionId,\n        uint256 outcomeSlotCount,\n        uint256[] payoutNumerators\n    );\n\n    /// @dev Emitted when a position is successfully split.\n    event PositionSplit(\n        address indexed stakeholder,\n        address collateralToken,\n        bytes32 indexed parentCollectionId,\n        bytes32 indexed conditionId,\n        uint256[] partition,\n        uint256 amount\n    );\n    /// @dev Emitted when positions are successfully merged.\n    event PositionsMerge(\n        address indexed stakeholder,\n        address collateralToken,\n        bytes32 indexed parentCollectionId,\n        bytes32 indexed conditionId,\n        uint256[] partition,\n        uint256 amount\n    );\n    event PayoutRedemption(\n        address indexed redeemer,\n        address indexed collateralToken,\n        bytes32 indexed parentCollectionId,\n        bytes32 conditionId,\n        uint256[] indexSets,\n        uint256 payout\n    );\n}\n\ninterface IConditionalTokens is IConditionalTokensEE, IERC1155 {\n    function payoutNumerators(bytes32 conditionId, uint256 index) external view returns (uint256);\n\n    function payoutDenominator(bytes32 conditionId) external view returns (uint256);\n\n    /// @dev This function prepares a condition by initializing a payout vector associated with the\n    /// condition.\n    /// @param oracle The account assigned to report the result for the prepared condition.\n    /// @param questionId An identifier for the question to be answered by the oracle.\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition.\n    /// Must not exceed 256.\n    function prepareCondition(address oracle, bytes32 questionId, uint256 outcomeSlotCount) external;\n\n    /// @dev Called by the oracle for reporting results of conditions. Will set the payout vector\n    /// for the condition with the ID ``keccak256(abi.encodePacked(oracle, questionId,\n    /// outcomeSlotCount))``, where oracle is the message sender, questionId is one of the\n    /// parameters of this function, and outcomeSlotCount is the length of the payouts parameter,\n    /// which contains the payoutNumerators for each outcome slot of the condition.\n    /// @param questionId The question ID the oracle is answering for\n    /// @param payouts The oracle's answer\n    function reportPayouts(bytes32 questionId, uint256[] calldata payouts) external;\n\n    /// @dev This function splits a position. If splitting from the collateral, this contract will\n    /// attempt to transfer `amount` collateral from the message sender to itself. Otherwise, this\n    /// contract will burn `amount` stake held by the message sender in the position being split\n    /// worth of EIP 1155 tokens. Regardless, if successful, `amount` stake will be minted in the\n    /// split target positions. If any of the transfers, mints, or burns fail, the transaction will\n    /// revert. The transaction will also revert if the given partition is trivial, invalid, or\n    /// refers to more slots than the condition is prepared with.\n    /// @param collateralToken The address of the positions' backing collateral token.\n    /// @param parentCollectionId The ID of the outcome collections common to the position being\n    /// split and the split target positions. May be null, in which only the collateral is shared.\n    /// @param conditionId The ID of the condition to split on.\n    /// @param partition An array of disjoint index sets representing a nontrivial partition of the\n    /// outcome slots of the given condition. E.g. A|B and C but not A|B and B|C (is not disjoint).\n    /// Each element's a number which, together with the condition, represents the outcome\n    /// collection. E.g. 0b110 is A|B, 0b010 is B, etc.\n    /// @param amount The amount of collateral or stake to split.\n    function splitPosition(\n        address collateralToken,\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256[] calldata partition,\n        uint256 amount\n    ) external;\n\n    function mergePositions(\n        address collateralToken,\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256[] calldata partition,\n        uint256 amount\n    ) external;\n\n    function redeemPositions(\n        address collateralToken,\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256[] calldata indexSets\n    ) external;\n\n    /// @dev Gets the outcome slot count of a condition.\n    /// @param conditionId ID of the condition.\n    /// @return Number of outcome slots associated with a condition, or zero if condition has not\n    /// been prepared yet.\n    function getOutcomeSlotCount(bytes32 conditionId) external view returns (uint256);\n\n    /// @dev Constructs a condition ID from an oracle, a question ID, and the outcome slot count for\n    /// the question.\n    /// @param oracle The account assigned to report the result for the prepared condition.\n    /// @param questionId An identifier for the question to be answered by the oracle.\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition.\n    /// Must not exceed 256.\n    function getConditionId(address oracle, bytes32 questionId, uint256 outcomeSlotCount)\n        external\n        pure\n        returns (bytes32);\n\n    /// @dev Constructs an outcome collection ID from a parent collection and an outcome collection.\n    /// @param parentCollectionId Collection ID of the parent outcome collection, or bytes32(0) if\n    /// there's no parent.\n    /// @param conditionId Condition ID of the outcome collection to combine with the parent outcome\n    /// collection.\n    /// @param indexSet Index set of the outcome collection to combine with the parent outcome\n    /// collection.\n    function getCollectionId(bytes32 parentCollectionId, bytes32 conditionId, uint256 indexSet)\n        external\n        view\n        returns (bytes32);\n\n    /// @dev Constructs a position ID from a collateral token and an outcome collection. These IDs\n    /// are used as the ERC-1155 ID for this contract.\n    /// @param collateralToken Collateral token which backs the position.\n    /// @param collectionId ID of the outcome collection associated with this position.\n    function getPositionId(address collateralToken, bytes32 collectionId) external pure returns (uint256);\n}\n"
    },
    "lib/solmate/src/tokens/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "lib/exchange-fee-module/src/mixins/Auth.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { IAuth } from \"../interfaces/IAuth.sol\";\n\n/// @title Auth\n/// @notice Provides access control modifiers\nabstract contract Auth is IAuth {\n    /// @notice Auth\n    mapping(address => uint256) public admins;\n\n    modifier onlyAdmin() {\n        if (admins[msg.sender] != 1) revert NotAdmin();\n        _;\n    }\n\n    constructor() {\n        admins[msg.sender] = 1;\n    }\n\n    /// @notice Adds an Admin\n    /// @param admin - The address of the admin\n    function addAdmin(address admin) external onlyAdmin {\n        admins[admin] = 1;\n        emit NewAdmin(msg.sender, admin);\n    }\n\n    /// @notice Removes an admin\n    /// @param admin - The address of the admin to be removed\n    function removeAdmin(address admin) external onlyAdmin {\n        admins[admin] = 0;\n        emit RemovedAdmin(msg.sender, admin);\n    }\n\n    /// @notice Renounces Admin privileges from the caller\n    function renounceAdmin() external onlyAdmin {\n        admins[msg.sender] = 0;\n        emit RemovedAdmin(msg.sender, msg.sender);\n    }\n\n    /// @notice Checks if an address is an admin\n    /// @param addr - The address to be checked\n    function isAdmin(address addr) external view returns (bool) {\n        return admins[addr] == 1;\n    }\n}\n"
    },
    "lib/exchange-fee-module/src/mixins/Transfers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { TransferHelper } from \"../libraries/TransferHelper.sol\";\n\ncontract Transfers {\n    /// @notice Transfers tokens. no-op if amount is zero\n    /// @param token    - The Token to be transferred\n    /// @param from     - The originating address\n    /// @param to       - The destination address\n    /// @param id       - The TokenId to be transferred, 0 if ERC20\n    /// @param amount   - The amount of tokens to be transferred\n    function _transfer(address token, address from, address to, uint256 id, uint256 amount) internal {\n        if (amount > 0) {\n            if (id == 0) {\n                return from == address(this)\n                    ? TransferHelper._transferERC20(token, to, amount)\n                    : TransferHelper._transferFromERC20(token, from, to, amount);\n            }\n            return TransferHelper._transferFromERC1155(token, from, to, id, amount);\n        }\n    }\n}\n"
    },
    "lib/exchange-fee-module/src/interfaces/IExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Order } from \"../libraries/Structs.sol\";\n\ninterface IExchange {\n    function getCollateral() external view returns (address);\n\n    function getCtf() external view returns (address);\n\n    function matchOrders(\n        Order memory takerOrder,\n        Order[] memory makerOrders,\n        uint256 takerFillAmount,\n        uint256[] memory makerFillAmounts\n    ) external;\n}\n"
    },
    "lib/exchange-fee-module/src/interfaces/IFeeModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Order } from \"../libraries/Structs.sol\";\n\ninterface IFeeModuleEE {\n    /// @notice Emitted when fees are withdrawn from the FeeModule\n    event FeeWithdrawn(address token, address to, uint256 id, uint256 amount);\n\n    /// @notice Emitted when fees are refunded to the order maker\n    event FeeRefunded(address token, address to, uint256 id, uint256 amount);\n}\n\ninterface IFeeModule is IFeeModuleEE {\n    function matchOrders(\n        Order memory takerOrder,\n        Order[] memory makerOrders,\n        uint256 takerFillAmount,\n        uint256[] memory makerFillAmounts,\n        uint256 makerFeeRate\n    ) external;\n\n    function withdrawFees(address to, uint256 id, uint256 amount) external;\n}\n"
    },
    "lib/exchange-fee-module/src/libraries/Structs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nenum Side {\n    // 0: buy\n    BUY,\n    // 1: sell\n    SELL\n}\n\nenum SignatureType {\n    // 0: ECDSA EIP712 signatures signed by EOAs\n    EOA,\n    // 1: EIP712 signatures signed by EOAs that own Polymarket Proxy wallets\n    POLY_PROXY,\n    // 2: EIP712 signatures signed by EOAs that own Polymarket Gnosis safes\n    POLY_GNOSIS_SAFE\n}\n\nstruct OrderStatus {\n    bool isFilledOrCancelled;\n    uint256 remaining;\n}\n\nstruct Order {\n    /// @notice Unique salt to ensure entropy\n    uint256 salt;\n    /// @notice Maker of the order, i.e the source of funds for the order\n    address maker;\n    /// @notice Signer of the order\n    address signer;\n    /// @notice Address of the order taker. The zero address is used to indicate a public order\n    address taker;\n    /// @notice Token Id of the CTF ERC1155 asset to be bought or sold\n    /// If BUY, this is the tokenId of the asset to be bought, i.e the makerAssetId\n    /// If SELL, this is the tokenId of the asset to be sold, i.e the takerAssetId\n    uint256 tokenId;\n    /// @notice Maker amount, i.e the maximum amount of tokens to be sold\n    uint256 makerAmount;\n    /// @notice Taker amount, i.e the minimum amount of tokens to be received\n    uint256 takerAmount;\n    /// @notice Timestamp after which the order is expired\n    uint256 expiration;\n    /// @notice Nonce used for onchain cancellations\n    uint256 nonce;\n    /// @notice Fee rate, in basis points, charged to the order maker, charged on proceeds\n    uint256 feeRateBps;\n    /// @notice The side of the order: BUY or SELL\n    Side side;\n    /// @notice Signature type used by the Order: EOA, POLY_PROXY or POLY_GNOSIS_SAFE\n    SignatureType signatureType;\n    /// @notice The order signature\n    bytes signature;\n}\n"
    },
    "lib/exchange-fee-module/src/libraries/CalculatorHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Order, Side } from \"../libraries/Structs.sol\";\n\nlibrary CalculatorHelper {\n    uint256 internal constant ONE = 10 ** 18;\n\n    uint256 internal constant BPS_DIVISOR = 10_000;\n\n    /// @notice Calculates the fee refund for an Order\n    /// @notice Used to refund Order makers if a user signs a fee into an Order that is > the expeceted fee\n    /// @param orderFeeRateBps      - The fee rate signed into the order by the user\n    /// @param operatorFeeRateBps   - The fee rate chosen by the operator\n    /// @param outcomeTokens        - The number of outcome tokens\n    /// @param makerAmount          - The maker amount of the order\n    /// @param takerAmount          - The taker amount of the order\n    /// @param side                 - The side of the order\n    function calcRefund(\n        uint256 orderFeeRateBps,\n        uint256 operatorFeeRateBps,\n        uint256 outcomeTokens,\n        uint256 makerAmount,\n        uint256 takerAmount,\n        Side side\n    ) internal pure returns (uint256) {\n        if (orderFeeRateBps <= operatorFeeRateBps) return 0;\n\n        uint256 fee = calculateFee(orderFeeRateBps, outcomeTokens, makerAmount, takerAmount, side);\n\n        // fee calced using order fee minus fee calced using the operator fee\n        if (operatorFeeRateBps == 0) return fee;\n        return fee - calculateFee(operatorFeeRateBps, outcomeTokens, makerAmount, takerAmount, side);\n    }\n\n    /// @notice Calculates the taking amount, i.e the amount of tokens to be received\n    /// @param makingAmount - The making amount\n    /// @param makerAmount  - The maker amount of the order\n    /// @param takerAmount  - The taker amount of the order\n    function calculateTakingAmount(uint256 makingAmount, uint256 makerAmount, uint256 takerAmount)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (makerAmount == 0) return 0;\n        return makingAmount * takerAmount / makerAmount;\n    }\n\n    /// @notice Calculates the fee for an order\n    /// @dev Fees are calculated based on amount of outcome tokens and the order's feeRate\n    /// @param feeRateBps       - Fee rate, in basis points\n    /// @param outcomeTokens    - The number of outcome tokens\n    /// @param makerAmount      - The maker amount of the order\n    /// @param takerAmount      - The taker amount of the order\n    /// @param side             - The side of the order\n    function calculateFee(\n        uint256 feeRateBps,\n        uint256 outcomeTokens,\n        uint256 makerAmount,\n        uint256 takerAmount,\n        Side side\n    ) internal pure returns (uint256 fee) {\n        if (feeRateBps > 0) {\n            uint256 price = _calculatePrice(makerAmount, takerAmount, side);\n            if (price > 0 && price <= ONE) {\n                if (side == Side.BUY) {\n                    // Fee charged on Token Proceeds:\n                    // baseRate * min(price, 1-price) * (outcomeTokens/price)\n                    fee = (feeRateBps * min(price, ONE - price) * outcomeTokens) / (price * BPS_DIVISOR);\n                } else {\n                    // Fee charged on Collateral proceeds:\n                    // baseRate * min(price, 1-price) * outcomeTokens\n                    fee = feeRateBps * min(price, ONE - price) * outcomeTokens / (BPS_DIVISOR * ONE);\n                }\n            }\n        }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function _calculatePrice(uint256 makerAmount, uint256 takerAmount, Side side) internal pure returns (uint256) {\n        if (side == Side.BUY) return takerAmount != 0 ? makerAmount * ONE / takerAmount : 0;\n        return makerAmount != 0 ? takerAmount * ONE / makerAmount : 0;\n    }\n}\n"
    },
    "lib/exchange-fee-module/src/interfaces/IAuth.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface IAuthEE {\n    error NotAdmin();\n\n    /// @notice Emitted when a new admin is added\n    event NewAdmin(address indexed admin, address indexed newAdminAddress);\n\n    /// @notice Emitted when an admin is removed\n    event RemovedAdmin(address indexed admin, address indexed removedAdmin);\n}\n\ninterface IAuth is IAuthEE {\n    function isAdmin(address) external view returns (bool);\n\n    function addAdmin(address) external;\n\n    function removeAdmin(address) external;\n\n    function renounceAdmin() external;\n}\n"
    },
    "lib/exchange-fee-module/src/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity <0.9.0;\n\nimport { ERC1155 } from \"solmate/tokens/ERC1155.sol\";\nimport { SafeTransferLib, ERC20 } from \"solmate/utils/SafeTransferLib.sol\";\n\n/// @title TransferHelper\n/// @notice Helper method to transfer tokens\nlibrary TransferHelper {\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @param token    - The contract address of the token which will be transferred\n    /// @param to       - The recipient of the transfer\n    /// @param amount   - The amount to be transferred\n    function _transferERC20(address token, address to, uint256 amount) internal {\n        SafeTransferLib.safeTransfer(ERC20(token), to, amount);\n    }\n\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @param token    - The contract address of the token to be transferred\n    /// @param from     - The originating address from which the tokens will be transferred\n    /// @param to       - The destination address of the transfer\n    /// @param amount   - The amount to be transferred\n    function _transferFromERC20(address token, address from, address to, uint256 amount) internal {\n        SafeTransferLib.safeTransferFrom(ERC20(token), from, to, amount);\n    }\n\n    /// @notice Transfer an ERC1155 token\n    /// @param token    - The contract address of the token to be transferred\n    /// @param from     - The originating address from which the tokens will be transferred\n    /// @param to       - The destination address of the transfer\n    /// @param id       - The tokenId of the token to be transferred\n    /// @param amount   - The amount to be transferred\n    function _transferFromERC1155(address token, address from, address to, uint256 id, uint256 amount) internal {\n        ERC1155(token).safeTransferFrom(from, to, id, amount, \"\");\n    }\n}\n"
    },
    "lib/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "lib/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "solmate/=lib/solmate/src/",
      "forge-gas-snapshot/=lib/forge-gas-snapshot/src/",
      "openzeppelin-contracts/=lib/ctf-exchange/lib/openzeppelin-contracts/contracts/",
      "common/=lib/ctf-exchange/src/common/",
      "creator/=lib/ctf-exchange/src/creator/",
      "ctf-exchange/=lib/ctf-exchange/src/",
      "dev/=lib/ctf-exchange/src/dev/",
      "exchange-fee-module/=lib/exchange-fee-module/src/",
      "exchange/=lib/ctf-exchange/src/exchange/",
      "openzeppelin/=lib/ctf-exchange/lib/openzeppelin-contracts/contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}